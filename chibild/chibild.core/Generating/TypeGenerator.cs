/////////////////////////////////////////////////////////////////////////////////////
//
// chibicc-toolchain - The specialized backend toolchain for chibicc-cil
// Copyright (c) Kouji Matsui(@kozy_kekyo, @kekyo @mastodon.cloud)
//
// Licensed under MIT: https://opensource.org/licenses/MIT
//
/////////////////////////////////////////////////////////////////////////////////////

using chibicc.toolchain.Parsing;
using chibicc.toolchain.Tokenizing;
using Mono.Cecil;
using Mono.Cecil.Rocks;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace chibild.Generating;

public static partial class TypeGenerator
{
    // "Fixed length array type" is a special type that does not exist in the .NET CLS
    // and is in fact a structure type with a valid storage size.
    // Of course, cannot be directly generated by Cecil,
    // nor can its type be directly determined by metadata.
    // However, if it is an AST, it can be confirmed that
    // it is by the existence of the length of `ArrayTypeNode`.
    
    public static TypeNode[] FilterRequiredPrioritizedCilBasisTypes(TypeNode type)
    {
        // This method extracts all `TypeReference` needed to convert a given AST
        // to a .NET type.
        // All `TypeNode` are considered necessary except for types
        // that can be synthesized by Cecil, which searches and collects ASTs.
        
        // The order of the list of returned types is important.
        // Resolving types in this order allows subsequent types in the list to be safely constructed.

        // Recursive crawler.
        static void InnerFilter(TypeNode type, List<TypeNode> types)
        {
            switch (type)
            {
                // Termination type.
                case TypeIdentityNode _:
                    types.Add(type);
                    return;
                
                // .NET array type.
                case ArrayTypeNode(var elementType, _):
                    InnerFilter(elementType, types);
                    return;

                // Fixed length array type.
                case FixedLengthArrayTypeNode(var elementType, _, _):
                    InnerFilter(elementType, types);
                    // Contains this.
                    // Will construct fixed length array type by caller.
                    types.Add(type);
                    return;

                // Reference/Pointer type.
                case DerivedTypeNode(_, var elementType, _):
                    InnerFilter(elementType, types);
                    return;
                
                // Function signature.
                case FunctionSignatureNode(var returnType, var parameters, _, _):
                    InnerFilter(returnType, types);
                    foreach (var parameter in parameters)
                    {
                        InnerFilter(parameter.ParameterType, types);
                    }
                    return;

                default:
                    throw new InvalidOperationException();
            }
        }

        var requiredTypes = new List<TypeNode>();
        InnerFilter(type, requiredTypes);
        return requiredTypes.
            Distinct().   // Distinct operator maintains ordering.
            ToArray();
    }

    public static TypeReference ConstructCilType(
        TypeNode type,
        IReadOnlyDictionary<string, TypeReference> requiredTypeReferences)
    {
        // Recursive type constructor.
        // Return to .NET type (TypeReference).
        static TypeReference InnerConstructor(
            TypeNode type,
            IReadOnlyDictionary<string, TypeReference> requiredTypeReferences)
        {
            switch (type)
            {
                // Termination type.
                case TypeIdentityNode _:
                    return requiredTypeReferences[type.CilTypeName];

                // .NET array type.
                case ArrayTypeNode(var elementType, _):
                    return InnerConstructor(
                        elementType,
                        requiredTypeReferences).
                        MakeArrayType();

                // Fixed length array type.
                case FixedLengthArrayTypeNode _:
                    return requiredTypeReferences[type.CilTypeName];

                // Function pointer. (Pointer of function signature)
                case DerivedTypeNode(
                    DerivedTypes.Pointer,
                    FunctionSignatureNode(var returnType, var parameters, var callingConvention, _),
                    _):
                    var fpt = new FunctionPointerType()
                    {
                        ReturnType = InnerConstructor(
                            returnType,
                            requiredTypeReferences),
                        CallingConvention = callingConvention switch
                        {
                            chibicc.toolchain.Parsing.MethodCallingConvention.VarArg =>
                                Mono.Cecil.MethodCallingConvention.VarArg,
                            _ =>
                                Mono.Cecil.MethodCallingConvention.Default,
                        },
                        HasThis = false,
                        ExplicitThis = false,
                    };
                    foreach (var (parameterType, parameterName, _) in parameters)
                    {
                        fpt.Parameters.Add(new(
                            parameterName,
                            ParameterAttributes.None,
                            InnerConstructor(
                                parameterType,
                                requiredTypeReferences)));
                    }
                    return fpt;

                // Pointer.
                case DerivedTypeNode(DerivedTypes.Pointer, var elementType, _):
                    return InnerConstructor(
                        elementType,
                        requiredTypeReferences).
                        MakePointerType();

                // Reference type.
                case DerivedTypeNode(DerivedTypes.Reference, var elementType, _):
                    return InnerConstructor(
                        elementType,
                        requiredTypeReferences).
                        MakeByReferenceType();
                
                // Note: The stand-alone function signature is not determined here,
                // because it is a call site and there is no corresponding .NET type.
                // case FunctionSignatureNode(...):

                default:
                    throw new InvalidOperationException();
            }
        }

        return InnerConstructor(
            type,
            requiredTypeReferences);
    }
    
    //////////////////////////////////////////////////////////////////////////

    public static TypeNode GetTypeNode(TypeReference type) =>
        type switch
        {
            // Function pointer type.
            FunctionPointerType functionPointerType => new DerivedTypeNode(
                DerivedTypes.Pointer,
                new FunctionSignatureNode(
                    GetTypeNode(functionPointerType.ReturnType),
                    functionPointerType.Parameters.
                        Select(p => new FunctionParameterNode(GetTypeNode(p.ParameterType), p.Name, Token.Unknown)).
                        ToArray(),
                    functionPointerType.CallingConvention switch
                    {
                        Mono.Cecil.MethodCallingConvention.VarArg =>
                            chibicc.toolchain.Parsing.MethodCallingConvention.VarArg,
                        _ =>
                            chibicc.toolchain.Parsing.MethodCallingConvention.Default,
                    },
                    Token.Unknown),
                Token.Unknown),

            // Pointer type.
            PointerType pointerType => new DerivedTypeNode(
                DerivedTypes.Pointer,
                GetTypeNode(pointerType.ElementType),
                Token.Unknown),

            // Reference type.
            ByReferenceType byReferenceType => new DerivedTypeNode(
                DerivedTypes.Reference,
                GetTypeNode(byReferenceType.ElementType),
                Token.Unknown),

            // .NET array type.
            ArrayType arrayType => new ArrayTypeNode(
                GetTypeNode(arrayType.ElementType),
                Token.Unknown),

            // TODO: Fixed length array type.
            //TypeReference { IsValueType: true, } tr => new ArrayTypeNode(
            //    GetTypeNode(arrayType.ElementType),
            //    null,
            //    Token.Unknown),

            // Termination type.
            _ => new TypeIdentityNode(
                type.Namespace == "C.type" ? type.Name : type.FullName,
                Token.Unknown),
        };

    public static FunctionSignatureNode GetFunctionSignature(MethodReference method)
    {
        var parameters = method.Parameters.
            Select(pd => new FunctionParameterNode(
                GetTypeNode(pd.ParameterType),
                pd.Name,
                Token.Unknown)).
            ToArray();
        
        return new(
            GetTypeNode(method.ReturnType),
            parameters,
            method.CallingConvention switch
            {
                Mono.Cecil.MethodCallingConvention.VarArg =>
                    chibicc.toolchain.Parsing.MethodCallingConvention.VarArg,
                _ =>
                    chibicc.toolchain.Parsing.MethodCallingConvention.Default,
            },
            Token.Unknown);
    }

    public static string GetCilTypeName(TypeReference type)
    {
        static string InnerTypeName(TypeReference type)
        {
            switch (type)
            {
                // .NET array type.
                case ArrayType _:
                    return $"{InnerTypeName(type.GetElementType()!)}[]";

                // Nested reference type.
                case ByReferenceType _:
                    return $"{InnerTypeName(type.GetElementType()!)}&";

                // Nested pointer type.
                case PointerType _:
                    return $"{InnerTypeName(type.GetElementType()!)}*";

                // Function pointer type.
                case FunctionPointerType fpt:
                    var rtn = InnerTypeName(fpt.ReturnType);
                    var ptns = fpt.Parameters.Select(p => InnerTypeName(p.ParameterType));
                    return $"{rtn}({string.Join(",", ptns)})*";

                default:
                    return type.Namespace == "C.type" ?
                        type.Name :
                        type.FullName!;
            }
        }
        
        return InnerTypeName(type);
    }
}
